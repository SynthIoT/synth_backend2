# services/ai_service.py
import re
import json
from typing import Dict, Any, Optional

# Patterns
TIME_RANGE_REGEX = re.compile(
    r"(\b\d{1,2}(?::\d{2})?\s?(?:am|pm|AM|PM)?\b)\s*(?:-|to|–|—)\s*(\d{1,2}(?::\d{2})?\s?(?:am|pm|AM|PM)?)"
)
SINGLE_TIME_REGEX = re.compile(r"\b(at|around|from)?\s*(\d{1,2}(?::\d{2})?\s?(?:am|pm|AM|PM)?)\b")
TIME_WORDS_REGEX = re.compile(r"\b(morning|afternoon|evening|night|noon|midnight)\b", re.I)

SEASON_KEYWORDS = {
    "summer": ["summer", "hot", "heat"],
    "winter": ["winter", "cold", "chilly"],
    "monsoon": ["monsoon", "rain", "rainy"],
    "spring": ["spring"],
    "autumn": ["autumn", "fall"],
}

LOCATION_PREPS = ["in", "at", "for", "near", "around"]

def _extract_time(prompt: str) -> Optional[str]:
    m = TIME_RANGE_REGEX.search(prompt)
    if m:
        a, b = m.group(1).strip(), m.group(2).strip()
        return f"{a} - {b}"
    m2 = SINGLE_TIME_REGEX.search(prompt)
    if m2:
        return m2.group(2).strip()
    m3 = TIME_WORDS_REGEX.search(prompt)
    if m3:
        return m3.group(1).lower()
    return None

def _extract_location(prompt: str) -> Optional[str]:
    for p in LOCATION_PREPS:
        pattern = rf"\b{p}\s+([A-Z]?[a-zA-Z0-9\-\s\.]+)"
        m = re.search(pattern, prompt)
        if m:
            candidate = m.group(1).split(",")[0].strip()
            candidate = re.split(r"\b(at|from|between|and|for|with)\b", candidate)[0].strip()
            if candidate:
                return candidate.title()
    tokens = re.findall(r"[A-Z][a-z]{2,}", prompt)
    if tokens:
        return " ".join(tokens[:2])
    return None

def _extract_ac(prompt: str) -> Optional[str]:
    low = prompt.lower()
    if "ac" not in low and "air conditioner" not in low:
        return None
    m = re.search(r"\b(?:ac|air conditioner)[^\w]{0,5}?(is\s*)?(on|off)\b", low)
    if m:
        return m.group(2)
    m2 = re.search(r"\b(?:ac|air conditioner)[^\d]{0,6}(\d{1,2}(?:\.\d)?\s?(?:c|f)?)\b", low)
    if m2:
        return m2.group(1).replace(" ", "").upper()
    m3 = re.search(r"\b(turn|switch|set)\s+(on|off|to)\s+(ac|air conditioner)\b", low)
    if m3:
        return m3.group(2)
    return "mentioned"

def _extract_season(prompt: str) -> Optional[str]:
    low = prompt.lower()
    for season, kws in SEASON_KEYWORDS.items():
        for kw in kws:
            if kw in low:
                return season
    return None

def _extract_indoor(prompt: str) -> Optional[str]:
    low = prompt.lower()
    if re.search(r"\b(indoor|inside|indoors|home|inside use)\b", low):
        return "indoor"
    if re.search(r"\b(outdoor|outside|outdoors)\b", low):
        return "outdoor"
    return None

def _extract_request_type(prompt: str) -> Optional[str]:
    low = prompt.lower()
    candidates = [
        "temperature",
        "temp",
        "humidity",
        "pressure",
        "wind",
        "co2",
        "pm2.5",
        "pm10",
        "light",
        "sound",
    ]
    for c in candidates:
        if c in low:
            if c == "temp":
                return "temperature"
            return c
    return None

def parse_prompt(prompt: str) -> Dict[str, Any]:
    if not prompt or not prompt.strip():
        raise ValueError("Empty prompt")
    request_type = _extract_request_type(prompt)
    ac = _extract_ac(prompt)
    time_expr = _extract_time(prompt)
    location = _extract_location(prompt)
    season = _extract_season(prompt)
    indoor = _extract_indoor(prompt)
    conf = {
        "request_type": 100 if request_type else 0,
        "ac": 90 if ac else 0,
        "time": 90 if time_expr else 0,
        "location": 80 if location else 0,
        "season": 80 if season else 0,
        "indoor": 80 if indoor else 0,
    }
    return {
        "ac": ac,
        "request_type": request_type,
        "location": location,
        "time": time_expr,
        "season": season,
        "indoor": indoor,
        "raw_prompt": prompt,
        "confidence": conf,
    }

def format_reply(params: Dict[str, Any]) -> str:
    req = params.get("request_type") or "requested data"
    ac = params.get("ac") or "unspecified"
    loc = params.get("location") or "unspecified location"
    time = params.get("time") or "unspecified time"
    season = params.get("season") or "unspecified season"
    indoor = params.get("indoor") or "unspecified (indoor/outdoor)"
    req_phrase = "a temperature data" if "temperature" in str(req).lower() else f"the requested data ({req})"
    message = (
        f"You have requested for {req_phrase}. "
        f"AC: {ac}. "
        f"Location: {loc}. "
        f"Time: {time}. "
        f"Season: {season}. "
        f"Indoor/Outdoor: {indoor}. "
        "Your data is getting generated by our model. "
        "You can download the data from your browser's download history when it's ready."
    )
    low = [k for k, v in params.get("confidence", {}).items() if v < 60]
    if low:
        message += " Note: low confidence detecting: " + ", ".join(low) + "."
    return message

def parse_and_respond(prompt: str) -> Dict[str, Any]:
    parsed = parse_prompt(prompt)
    message = format_reply(parsed)
    return {"params": parsed, "message": message}

# quick test
if __name__ == "__main__":
    print(parse_and_respond("Generate a temperate data in chennai from 3-4 pm"))
